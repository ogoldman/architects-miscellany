
= The Collaborative Authoring Cloud Architecture Style

:toc:

_Document collaboration_ is a category of software providing multiple people the ability to work collaboratively on one or more shared documents. <<dc>> 
These systems vary along several axes--how many people, what types of and how many documents, the nature of the collaboration.
Nonetheless, overall, they support similar capabilities.
The systems that implement them have accordingly similar architectures that can be considered part of the same style.

This essay describes that style, the considerations that inform it, and the capabilities it supports.
It begins by describing associated concepts, including _documents_ and _collaboration_ -- both terms require some explanation.
The architectural style is then described primarily as a logical decomposition of the four primary elements in all designs based on this style.
Some attention is given to deployment considerations, as many of these systems are global and the physical placement of storage and compute resources is a significant consideration.
Further detail on process and development views are omitted; these would necessarily be a function of implementation choices that will vary amongst different architectures conforming to this one style.

Readers, once familiar with this style, will be able to recognize its structure in existing systems and assess whether their use cases call for such a design.
Some real-world systems are briefly described as applications of this style.
Architects working with collaborative authoring cloud systems will find in this style a first-level logical decomposition that can help underpin the first few iterations of their design or guide its evolution.

== Documents as Concept

Conceptually, a document is a bounded set of information.
It can be stored somewhere.
It can be edited, copied, and deleted.
Because it can be edited and copied, multiple versions of a given document exist, and they may not all contain quite the same information.
We can reference documents but, because we cannot guarantee unique identifiers or names for documents, references may be ambiguous.

The "document" label suggests paged, textual data, such as authored via a text editor or word processor.
However, here we use the term broadly, encompassing related types including spreadsheets, presentations, three-dimensional models, songs, videos, and so on.
Indeed, the essential elements of a document for this discussion are that it's bounded and that it's authored.

As a counterexample, consider data (information) generated by a sensor.
Sensor data is not intrinsically bounded, but rather generated continuously. 
(It might later be divided into bounded sets for some of unit of time, but that is a derived representation.)
Nor is sensor data authored; it is simply captured, after which it is typically not to be modified.

=== Work in Progress

Intuitively, the documents we're addressing here correspond to "work in progress."
That is: data that is fixed upon capture, such as from a sensor, might be an input to work but is not the work itself.
Similarly, after the work is done, it might be published in some form intended, again, only for consumption--and the published work is not the work itself.
"Work in progress" documents are those that hold the many intermediates state between these inputs and outputs.

The notion has a strong affinity with files, and, prior to cloud computing, most documents were files stored on hard drives, attached to emails, and so on.
The two concepts are frequently interchangeable when discussing this architectural style, and some collaborative authoring systems are filed-based.
However, many implementations of this style typically do not store documents as files, or at least do not always do so--as is discussed below.
To avoid confusing the essential concept of a "bounded set of information" with a specific storage representation, we'll avoid referencing _files_ unless deliberately discussing the storage of a document in a file.

=== Relationships

When we say that the documents are bounded, we mean that we can identify the full set of information that, should we store a document in a file, would have to be persisted in that file.
As is discussed later, the ability to define such a boundary is essential when considering versioning and concurrency control.
However, the scope of a collaboration doesn't always fit into a single boundary.

Again, most document types deal with a specific type of content, such as text or images.
A collaboration involving multiple types of content may, then, require coordinated use of several documents simply to store different types of content.
For these use cases, there is typically a single "root" document that provides the overall organization, with links to the "element" documents placed at certain points in the presentation.

For example, page layout applications often work this way.
They provide formatting, assigning content to pages.
The page layout document may--and often does--contain some of that content.
But elements--such as images--can be referenced from the layout document.

Sets of related documents are also commonly used when creating large works.
For example, consider the documentation for a software platform with tens of interfaces.
For each interface, the documentation will contain a guide, examples, and a reference.
Here it becomes cumbersome to treat all this information as a single document.
Instead, the collaboration involves the set of documents, each of which has its own identity, versions, and so on.


== Collaboration Concepts

In this context, a _collaboration_ is a cooperative effort by two or more persons to author (create or produce) one (or more) related documents.
It has a start and an end and a process, but these are not always rigorous or clear.
For our purposes, we will take note of the _mode_ of collaboration and the _roles_ that the participants play.

=== Modes

A collaboration proceeds in either or both of _synchronous_ and _asynchronous_ modes.
In synchronous collaboration, all individuals authoring a document are, logically, authoring the same version of the document.
If they're authoring at the same time, then they are seeing a (more-or-less) real-time view of each other's changes.
Given that behavior, this mode is usable when participants are also communicating in real-time, as via video or chat.
Some collaborative authoring systems provide or integrate with real-time communication systems for this reason.

Conversely, asynchronous collaboration permits individuals to isolate their work from others until an event triggers sharing with other participants.
When users are authoring at different times, the result need not be any different than the synchronous collaboration experience.
However, when users are authoring simultaneously, an asynchronous mode gives them, in effect, different copies of the document to work with.
In many designs, these "personal" copies can be be maintained indefinitely so that work in progress, even if taking many days to complete, can be completed asynchronously from other updates to the document.

All collaborative authoring systems support at least one of these two modes.
Some support both, albeit at some added complexity.
Note that neither is intrinsically better than the other.
Many aspects of relevant use cases, including document types, user roles (below), and other factors--all determine which model is preferable for any given scenario.

It is also true that designs for one mode can, within limits and with effort, be used to achieve behaviors of the other mode.
For example, a system designed for synchronous collaboration can be used asynchronously by managing when authors are present, or by having authors work on copies of the document in a separate tool.
Conversely, asynchronous systems can be pushed towards synchronous operation by triggering sharing early and often.
However, for the remainder of the discussion, we'll ignore such uses and focus on systems being used according to their design.

=== Roles

In describing collaboration modes, we've spoken vaguely about multiple participants "authoring" the same document.
However, these participants may play different roles during the collaboration.
Indeed, while not a strict taxonomy, the following list captures several significant roles:

[horizontal]
author:: Adds content--typically new, original content--to the the document.
editor:: Modifies the content for style or correctness, but does not add content.
reviewer:: Adds comments; might propose changes to content.
reader:: Can view the document but cannot make changes or add comments.

Not coincidentally, these roles correspond to common steps in the lifecycle of a document.
First it is authored, then edited, reviewed, and then published for readers.
Of course, these processes do not usually occur in a linear fashion.
Authoring, editing, and reviewing often occur in parallel and across multiple iterations.
Even after publishing, subsequent versions might be developed--perhaps based on reader feedback.
So while it is possible for document collaboration systems to embody some aspect of workflow, more frequently, they recognize different roles but stop short if imposing a role-based workflow.


== Overview

The essence of the collaborative authoring style is a division of responsibilities in four parts: a *repository* that stores documents, *clients* that edit those documents, a *synchronization mechanism* that manages the movement of data between the clients and the repository, and *services* that augment the other three elements.

[ditaa]
....
    + ------------------+                    +--------------+
    |                   |       use          |              |
    | Clients           | -----------------> | Services     |
    |                   |                    |              |
    +-------------------+                    +--------------+
           |                                        |
           | edit                                   | access
           v                                        v 
    +-------------------+    synchronization +--------------+
    |                   |      mechanism     |              |
    | synchronized data | -----------------> | Repository   |
    |                   |                    |              |
    +-------------------+                    +--------------+
....

=== Repository

The repository is the heart of any collaborative authoring system, as it stores the documents on which users are working.
Indeed, storage is at the core of its mission--if the repository can't store the documents, it can't do anything.
Any storage system, however, needs to make a host of decisions as to how it organizes what it stores, manages access to stored items, and so on.
And each of these has a significant impact on how the other three parts of the system--the clients, synchronization mechanism, and services--interact with those documents.

==== Identification and Organization

First and foremost, the repository must provide an _identification mechanism_ for the documents it stores.
Repositories will commonly assign fixed, unique identifiers (e.g. UUIDs <<uuid>>) to each document, which is useful for synchronization and programmatic access (discussed further, below).
However, these identifiers are not user-friendly, and so most systems also allow documents to be identified by name.

In theory, names can be organized in a few different ways.
For example, all names of all documents could be considered part of a single set, so each document has to have its own name.
Or, they could be organized into a tree, and thus need to be unique only within the context of their node in that tree.
Or, conceivably, names could be part of a graph.

In practice, trees have always proven to be the most useful organization mechanism for document names.
The single, flat namespace create by a single-set approach is too simple, and users quickly find themselves encoding structure into the names themselves.
Conversely, graphs are overly complex, eliminating the intuitive "up" and "down" navigation that trees provide.
Trees also play nicely with relative references (such as in Uniform Resource Identifiers <<uri>>) and access control (see below).

==== Revisions

Closely related to identification and organization, repositories must determine whether and how they record revisions to documents.
The simplest option is not to do so.
However, in a collaborative authoring environment, that is unlikely to be a realistic option.
Mistakes occurs and, when they do, users like to be able to "back up" to an older revision.

At the other extreme, a repository can keep every revision of every document.
Indeed, for some use cases, the ability to store and retrieve every revision is an essential feature.
Repositories can optimize away some of the implied storage cost by storing only the differences between each revision.
The Revision Control System <<rcs>> pioneered the use of _reverse deltas_ for this purpose, thus allowing the most recent revision to be retrieved quickly while still reducing the storage space required for older revisions.

Between these extremes, repositories must determine the circumstances under which the revision history can be changed.
It might be automatic.
For example, many repositories purge older revisions after a certain period of time, or at a maximum number of revisions.
(Quite a few products charge more to store more revisions, which is of course also commensurate with increased storage costs.)

Users may also have a role.
For example, users might be able to mark certain revisions as important, making it easier to return to them or preventing them from being purged.
Revisions are, as a rule, immutable.
However, once users can manage the revision history, the repository will need to support updates to metadata about those revisions.
Such features typically require further support from access control mechanisms (modifying revisions may require specific privileges) and the API.
And, of course, clients must be aware of these additional behaviors, perhaps providing corresponding user interface support.


==== Document Types

As they must determine how to identify the documents they contain, so to must repositories determine what types of documents they will store.
On this point, there exists a classic engineering trade-off between specialization and genericism.

A repository can restrict itself to one type, or perhaps a handful of types.
By adding such restrictions, a design opens up space to provide deeper capabilities with respect to the supported types.
For example, a repository that stores only JSON documents <<json>> can leverage that restriction to reduce storage costs (JSON is highly compressible) or optimize changes (e.g. JSON Patch <<json-patch>>).
Of course, this comes at a cost should a user ever wish to store some other type of document.

At the other extreme, a repository can be type agnostic.
Each document can be handled as an opaque stream of bytes.
A repository that takes this approach is, in some sense, future-proof: Clients can use it for new document types without any prior coordination.

Repositories can often make good use of middle-ground strategies.
That is, they should be prepared to support any document type to better support new clients and evolving use cases.
At the same time, certain document types--or "meta types", such as JSON--may be common.
When a given type or meta-type is common enough, a repository can achieve a good return on investment through specializations for those specific types.
Adobe's Digital Composite Technology <<dcx>>, for example, is a framework designed to provide just this kind of "middle-ground" optimization for a host of different document types.

==== Access Control

Of course, repositories don't store documents on just anyone's behalf; users must have appropriate privileges.
Which privileges are required, how they are assigned to users, and so on is all part of the repository's access control model.
In practice, repositories tend to take one of two approaches: privilege-based or role-based.

In privilege-based access control systems, users are directly granted (or denied) privileges based on their identity and an object.
For example, User A might be granted read and write access to a Document X, whereas User B might be granted only read access to the same document.
And, these privileges can only be changed by someone with a different privilege in the system--the privilege to grant (or deny) privileges to users.

Note that, while it's common in these systems to talk about privileges granting access to documents, they don't really work that way.
Privileges are assigned to _objects_, and some objects are documents--but not all of them.
Indeed, in the previous exmaple, the privilege to assign privileges for Document X isn't the same as a privilege to read or write Document X itself.
Rather, it's a privilege on the _access control object_ associated with Document X.

Moreover, while "read" and "write" are minimally necessary privileges, repositories can opt to create much fine-grained privilege sets.
For example, a system can separate privileges for reading the current vs. old revisions of a document, or even manage a read privilege per-revision.
And so on.

As is apparent from these examples, privilege-based systems have the advantage and disadvantage of being complex.
They are often found in systems designed for enterprises, where enterprise security requirements demand that administrators have certain levels of control.
For administrators, such controls are often necessary to _prevent_ unwarranted access by individuals who should not have access to confidential information.
Still, in practice, users of such systems often use only certain useful combinations of all available privileges.

Role-based systems simplify things by defining sets of related privileges and assigning roles, not privileges, to users.
Roles here often align with collaboration roles as discussed above: author, edit, reviewer, and so on.
Among other advantages, role-based systems tend to be more resilient (roles can be updated over time) and predictable (it's easier to understand roles than fine-grained privilege sets).



sharing
publishing

==== Other Considerations

API
scale
Metadata



=== Synchronization


== Client-Side Storage

* Sync everything 
  * file system-based
  * hidden
  * Lots of space

* Sync nothing
  * Cache only
  * Not predictable, hard to work offline

* Pinning
  * Give the user some control
  * Usually a two-part cache: pinned part, recent part

* virtual
  * Makes it look like everything is synchronized
  * Provides an obvious place for pinning controls
  * allows namespace operations on non-synced files

Shared vs. per application

Using different storage representations on client and server (and transfer)

==== Operational Modes

online vs. disconnected

==== Conflict Resolution

Online-only -- try to avoid conflicts
Operational transform -- very hard!
Presence -- try to avoid locking
Locking -- documents or sub-documents
Conflict-free Replicated Data Types
MVCC
Replay

Automatic resolution
User-driven resolution
Interplay with MVCC--does resolution have to  happen before upload?

=== Services

notifications
discoverability
search and recommendations

=== Clients

== Deployment

Tenancy models

Regionalization


== Examples


== Summary


[bibliography]
== References

* [[[dc,1]]] "Document Collaboration", _Wikipedia_ -- <link:https://en.wikipedia.org/wiki/Document_collaboration[]>

* [[[dcx,2]]] "Digital Composites: Technology for Creativity in a Cloud-Connected World", _2015 Internet Technologies and Applications_ -- <https://ieeexplore.ieee.org/document/7317385>

* [[[json,3]]] 

* [[[json-patch,4]]]

* [[[rcs,5]]] "Design, implementation, and evaluation of a Revision Control System", _ICSE '82: Proceedings of the 6th International Conference on Software Engineering_ -- <https://dl.acm.org/doi/10.5555/800254.807748>

* [[[uri,6]]] "Uniform Resource Identifier (URI): Generic Syntax", _RFC Editor Website_ -- <link:https://www.rfc-editor.org/rfc/rfc3986[]>

* [[[uuid,7]]] "A Universally Unique Identifier (UUID) URN Namespace", _RFC Editor Website_ -- <link:https://www.rfc-editor.org/rfc/rfc4122[]>

* https://www.figma.com/blog/how-figmas-multiplayer-technology-works/

* operational transform

* conflict-free replicated data types
