
= The Collaborative Authoring Cloud Architecture Style

_Document collaboration_ is a category of software providing multiple people the ability to work collaboratively on a shared document. <<dc>> 
These systems vary along several axes--how many people, what type of document, the nature of the collaboration.
Nonetheless, on the whole, they support similar capabilities.
The systems that implement them have accordingly similar architectures that can be considered part of the same style.
This essay describes that style, the considerations that inform it, and the capabilities it supports.

== Documents

For purposes of this conversation, a document is a bounded set of data.
The "document" label suggests paged, textual data, such as authored via a text editor or word processor.
However, here we use the term broadly, encompassing related types including spreadsheets, presentations, three-dimensional models, videos, and so on.

Indeed, the essential elements of a document for this discussion are that it's bounded and that it's authored.
As a counter-example, consider data generated by a sensor.
Sensor data is not intrinsically bounded, but rather generated continuously. 
(It might later be divided into bounded sets for some of unit of time, but that is a derived representation.)
Nor is sensor data authored; it is simply generated, after which it is typically not to be modified.

Intuitively, the documents we're addressing here correspond to "work in progress."
That is: data that is fixed upon capture, such as from a sensor, might be an input to work but is not the work itself.
Similarly, after the work is done, it might be published in some form intended, again, only for consumption--and the published work is not the work itself.
"Work in progress" documents are those that hold the many intermediates state between these inputs and outputs.

The notion has a strong affinity with files and, prior to cloud computing, most documents were files stored on hard drives, attached to emails, and so on.
For the most part, considering a document as a file will yield useful intuition when discussing this architectural style.
However, it is also true that implementations of this style typically do not store documents as files, or at least do not always do so--as is discussed below.
To avoid confusing the essential notion of a "bounded set of data" with a specific storage representation, we'll avoid referencing _files_ unless deliberately discussing the storage of a document in a file.

When we say that the documents are bounded, we mean that we can identify the full set of data that, should we store a document in a file, would have to be persisted in that file.
As is discussed later, the ability to define such a boundary is essential when considering versioning and concurrency control.
However, the scope of collaboration amongst a document's authors doesn't always fit into a single boundary.
Often, smaller documents might be composed into larger documents, either by value or by reference.
Therefore collaborative authoring systems, depending on their domain, may need to account for collaboration scenarios that involve multiple documents and supporting a variety of workflows via which links between documents may be managed.


== Collaboration

* synchronous vs. asynchrous 
* roles
* real-time

== Operational Modes

online vs. disconnected

== Conflict Resolution

Online-only -- try to avoid conflicts
Operational transform -- very hard!
Presence -- try to avoid locking
Locking -- documents or sub-documents
Conflict-free Replicated Data Types
MVCC
Replay

Automatic resolution
User-driven resolution
Interplay with MVCC--does resolution have to  happen before upload?

== Storage

Namespace
 * use names for variations -- for review, iteration, etc.
Document types
Metadata

== Metadata

== Sharing

=== Access Control

role-based
discretionary 
predictability

=== Notifications, Discoverability


== History

versioning, etc.

== Client-Side Storage

* Sync everything 
  * file system-based
  * hidden
  * Lots of space

* Sync nothing
  * Cache only
  * Not predictable, hard to work offline

* Pinning
  * Give the user some control
  * Usually a two-part cache: pinned part, recent part

* virtual
  * Makes it look like everything is synchronized
  * Provides an obvious place for pinning controls
  * allows namespace operations on non-synced files

Shared vs. per application

Using different storage representations on client and server (and transfer)

== Dealing with Linked and related documents

[bibliography]
== References

* [[[dc,1]]] "Document Collaboration", _Wikipedia_, -- <link:https://en.wikipedia.org/wiki/Document_collaboration[]>

* https://www.figma.com/blog/how-figmas-multiplayer-technology-works/
