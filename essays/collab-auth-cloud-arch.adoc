
= The Collaborative Authoring Cloud Architecture Style

:toc:

_Document collaboration_ is a category of software providing multiple people the ability to work collaboratively on one or more shared documents. <<dc>> 
These systems vary along several axes--how many people, what types of and how many documents, the nature of the collaboration.
Nonetheless, on the whole, they support similar capabilities.
The systems that implement them have accordingly similar architectures that can be considered part of the same style.

This essay describes that style, the considerations that inform it, and the capabilities it supports.
It begins by describing associated link:concept[concepts], including _documents_ and _collaboration_ -- both terms require some explanation.
The architectural style is then described primarily as a logical decomposition of the four primary elements in all designs based on this style.
Some attention is given to deployment considerations, as many of these systems are global and the physical placement of storage and compute resources is a significant consideration.
Further detail on process and development views are omitted; these would necessarily be a function of implementation choices that will vary amongst different architectures conforming to this one style.

Readers, once familiar with this style, will be able to recognize its structure in existing systems and assess whether their use cases call for such a design.
Some real-world systems are briefly described as applications of this style.
Architects working with collaborative authoring cloud systems will find in this style a first-level logical decomposition that can help underpin the first few iterations of their design or guide its evolution.

== Documents as Concept

Conceptually, a document is a bounded set of information.
It can be stored somewhere.
It can be edited, copied, and deleted.
Because it can be edited and copied, multiple versions of a given document exist, and they may not all contain quite the same information.
We can reference documents but, because we cannot guarantee unique identifiers or names for documents, references may be ambiguous.

The "document" label suggests paged, textual data, such as authored via a text editor or word processor.
However, here we use the term broadly, encompassing related types including spreadsheets, presentations, three-dimensional models, songs, videos, and so on.
Indeed, the essential elements of a document for this discussion are that it's bounded and that it's authored.

As a counter-example, consider data (information) generated by a sensor.
Sensor data is not intrinsically bounded, but rather generated continuously. 
(It might later be divided into bounded sets for some of unit of time, but that is a derived representation.)
Nor is sensor data authored; it is simply captured, after which it is typically not to be modified.

=== Work in Progress

Intuitively, the documents we're addressing here correspond to "work in progress."
That is: data that is fixed upon capture, such as from a sensor, might be an input to work but is not the work itself.
Similarly, after the work is done, it might be published in some form intended, again, only for consumption--and the published work is not the work itself.
"Work in progress" documents are those that hold the many intermediates state between these inputs and outputs.

The notion has a strong affinity with files and, prior to cloud computing, most documents were files stored on hard drives, attached to emails, and so on.
The two concepts are frequently interchangeable when discussing this architectural style, and some collaborative authoring systems are filed-based.
However, many implementations of this style typically do not store documents as files, or at least do not always do so--as is discussed below.
To avoid confusing the essential concept of a "bounded set of information" with a specific storage representation, we'll avoid referencing _files_ unless deliberately discussing the storage of a document in a file.

=== Relationships

When we say that the documents are bounded, we mean that we can identify the full set of information that, should we store a document in a file, would have to be persisted in that file.
As is discussed later, the ability to define such a boundary is essential when considering versioning and concurrency control.
However, the scope of a collaboration doesn't always fit into a single boundary.

Again, most document types deal with a specific type of content, such as text or images.
A collaboration involving multiples types of content may, then, require coordinated use of several documents simply to store different types of content.
For these use cases, there is typically a single "root" document that provides the overall organization, with links to the "element" documents placed at certain points in the presentation.

For example, page layout applications often work this way.
They provide formatting, assigning content to pages.
The page layout document may--and often does--contain some of that content.
But, elements--such as images--can be referenced from the layout document.

Sets of related documents are also commonly used when creating large works.
For example, consider the documentation for a software platform with tens of interfaces.
For each interface, the documentation will contain a guide, examples, and a reference.
Here it becomes cumbersome to treat all of this information as a single document.
Instead, the collaboration involves the set of documents, each of which has its own identity, versions, and so on.


== Collaboration Concepts

In this context, a _collaboration_ is a cooperative effort by two or more persons to author (create or produce) one (or more) related documents.
It has a start and an end and a process, but these are not always rigorous or clear.
For our purposes, we will take note of the _mode_ of collaboration and the _roles_ that the participants play.

=== Modes

A collaboration proceeds in either or both of _synchronous_ and _asynchronous_ modes.
In synchronous collaboration, all individuals authoring a document are, logically, authoring the same version of the document.
If they're authoring at the same time, then they are seeing a (more-or-less) real-time view of each other's changes.
Given that behavior, this mode is usable when participants are also communicating in real-time, as via video or chat.
Some collaborative authoring systems provide or integrate with real-time communication systems for this reason.

Conversely, asynchronous collaboration permits individuals to isolate their work from others until an event triggers sharing with other participants.
When users are authoring at different times, the result need not be any different than the synchronous collaboration experience.
However, when users are authoring simultaneously, an asynchronous mode gives them, in effect, different copies of the document to work with.
In many designs, these "personal" copies can be be maintained indefinitely so that work in progress, even if taking many days to complete, can be completed asynchronously from other updates to the document.

All collaborative authoring systems support at least one of these two modes.
Some support both, albeit at some added complexity.
Note that neither is intrinsically better than other.
Many aspects of relevant use cases, including document types, user roles (below), and other factors--all determine which model is preferable for any given scenario.

It is also true that designs for one mode can, within limits and with effort, be used to achieve behaviors of the other mode.
For example, a system designed for synchronous collaboration can be used asynchrously by managing when authors are present, or by having authors work on copies of the document in a separate tool.
Conversely, asynchronous systems can be pushed towards synchronous operation by triggering sharing early and often.
However, for the remainder of the discussion, we'll ignore such uses and focus on systems being used according to their design.

=== Roles

In describing collaboration modes, we've spoken vaguely about multiple participants "authoring" the same document.
However, these participants may play different roles during the collaboration.
Indeed, while not a strict taxonomy, the following list captures several signicant roles:

[horizontal]
author:: Adds content--typically new, original content--to the the document.
editor:: Modifies the content for style or correctness, but does not add content.
reviewer:: Adds comments; might propose changes to content.
reader:: Can view the document but cannot make changes or add comments.

Not coincidentally, these roles correspond to common steps in the lifecycle of a document.
First it is authored, then edited, reviewed, and then published for readers.
Of course, these processes do not usually occur in a linear fashion.
Authoring, editing, and reviewing often occur in parallel and across multiple iterations.
Even after publishing, subsequent versions might be developed--perhaps based on reader feedback.
So while it is possible for document collaboration systems to embody some aspect of workflow, more frequently, they recognize different roles but stop short if imposing a role-based workflow.


== Overview

The essence of the collaborative authoring style is a division of responsibilities in four parts: a *repository* that stores documents, *clients* that edit those documents, a *synchronization mechanism* that manages the movement of data between the clients and the repository, and *services* that augment these other three elements.

[ditaa]
....
    + ------------------+                    +--------------+
    |                   |       use          |              |
    | Clients           | -----------------> | Services     |
    |                   |                    |              |
    +-------------------+                    +--------------+
           |                                        |
           | edit                                   | access
           v                                        v 
    +-------------------+    synchronization +--------------+
    |                   |      mechanism     |              |
    | synchronized data | -----------------> | Repository   |
    |                   |                    |              |
    +-------------------+                    +--------------+
....

=== Repository

== Storage

Namespace
 * use names for variations -- for review, iteration, etc.
Document types
Metadata

== Metadata

== Sharing

=== Access Control

role-based
discretionary 
predictability

versioning


=== Synchronization


== Client-Side Storage

* Sync everything 
  * file system-based
  * hidden
  * Lots of space

* Sync nothing
  * Cache only
  * Not predictable, hard to work offline

* Pinning
  * Give the user some control
  * Usually a two-part cache: pinned part, recent part

* virtual
  * Makes it look like everything is synchronized
  * Provides an obvious place for pinning controls
  * allows namespace operations on non-synced files

Shared vs. per application

Using different storage representations on client and server (and transfer)

==== Operational Modes

online vs. disconnected

==== Conflict Resolution

Online-only -- try to avoid conflicts
Operational transform -- very hard!
Presence -- try to avoid locking
Locking -- documents or sub-documents
Conflict-free Replicated Data Types
MVCC
Replay

Automatic resolution
User-driven resolution
Interplay with MVCC--does resolution have to  happen before upload?

=== Services

notifications
discoverability
search and recommendations

=== Clients

== Examples


== Summary


[bibliography]
== References

* [[[dc,1]]] "Document Collaboration", _Wikipedia_, -- <link:https://en.wikipedia.org/wiki/Document_collaboration[]>

* https://www.figma.com/blog/how-figmas-multiplayer-technology-works/

* operational transform

* conflict-free replicated data types
